From 1f59f9ad49326eb603cffdd48ecfbc5a9aad212e Mon Sep 17 00:00:00 2001
From: wj <545818496@qq.com>
Date: Sat, 11 May 2024 16:41:37 +0800
Subject: [PATCH] update cn

---
 RetroFE/Source/CMakeLists.txt                 |  11 +
 RetroFE/Source/Collection/CollectionInfo.cpp  |   4 +-
 .../Collection/CollectionInfoBuilder.cpp      |   6 +-
 .../Component/ReloadableScrollingText.cpp     | 823 +++++++++---------
 RetroFE/Source/Graphics/Component/Text.cpp    | 149 ++--
 RetroFE/Source/Graphics/Font.cpp              | 224 ++---
 RetroFE/Source/Graphics/Font.h                |  29 +-
 RetroFE/Source/Menu/MenuMode.cpp              | 110 +--
 RetroFE/Source/SDL.cpp                        |   8 +-
 9 files changed, 691 insertions(+), 673 deletions(-)

diff --git a/RetroFE/Source/CMakeLists.txt b/RetroFE/Source/CMakeLists.txt
index 32e8454..59855eb 100755
--- a/RetroFE/Source/CMakeLists.txt
+++ b/RetroFE/Source/CMakeLists.txt
@@ -15,6 +15,17 @@ list(APPEND CMAKE_MODULE_PATH "${RETROFE_DIR}/CMake")
 
 set(SQLITE3_ROOT "${RETROFE_THIRD_PARTY_DIR}/sqlite3")
 set(RAPIDXML_ROOT "${RETROFE_THIRD_PARTY_DIR}/rapidxml-1.13")
+# set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")
+# SET(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb ")
+
+if(NOT CMAKE_BUILD_TYPE)
+set(CMAKE_BUILD_TYPE Release)
+endif()
+set(CMAKE_CXX_FLAGS_RELEASE -Ofast)
+ 
+set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -O3  -Wall")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O3  -Wall")
+
 
 if(WIN32)
 if(MSVC)
diff --git a/RetroFE/Source/Collection/CollectionInfo.cpp b/RetroFE/Source/Collection/CollectionInfo.cpp
index 94f8400..3819919 100755
--- a/RetroFE/Source/Collection/CollectionInfo.cpp
+++ b/RetroFE/Source/Collection/CollectionInfo.cpp
@@ -78,8 +78,8 @@ bool CollectionInfo::Save()
     bool retval = true;
     if(saveRequest)
     {
-        std::string dir  = Utils::combinePath(Configuration::absolutePath, "collections", name, "playlists");
-        std::string file = Utils::combinePath(Configuration::absolutePath, "collections", name, "playlists/favorites.txt");
+        std::string dir  = Utils::combinePath(Configuration::userPath, "collections", name, "playlists");
+        std::string file = Utils::combinePath(Configuration::userPath, "collections", name, "playlists/favorites.txt");
         Logger::write(Logger::ZONE_INFO, "Collection", "Saving " + file);
 
         Utils::rootfsWritable();
diff --git a/RetroFE/Source/Collection/CollectionInfoBuilder.cpp b/RetroFE/Source/Collection/CollectionInfoBuilder.cpp
index cd10b10..af14807 100755
--- a/RetroFE/Source/Collection/CollectionInfoBuilder.cpp
+++ b/RetroFE/Source/Collection/CollectionInfoBuilder.cpp
@@ -379,7 +379,7 @@ void CollectionInfoBuilder::addPlaylists(CollectionInfo *info)
 	DIR *dp;
     struct dirent **dirp;
     int n;
-    std::string path = Utils::combinePath(Configuration::absolutePath, "collections", info->name, "playlists");
+    std::string path = Utils::combinePath(Configuration::userPath, "collections", info->name, "playlists");
     dp = opendir(path.c_str());
 
     if(dp == NULL)
@@ -407,7 +407,7 @@ void CollectionInfoBuilder::addPlaylists(CollectionInfo *info)
                 Logger::write(Logger::ZONE_INFO, "RetroFE", "Loading playlist: " + basename);
 
                 std::map<std::string, Item *> playlistFilter;
-                std::string playlistFile = Utils::combinePath(Configuration::absolutePath, "collections", info->name, "playlists", file);
+                std::string playlistFile = Utils::combinePath(Configuration::userPath, "collections", info->name, "playlists", file);
                 ImportBasicList(info, playlistFile, playlistFilter);
 
                 info->playlists[basename] = new std::vector<Item *>();
@@ -479,6 +479,8 @@ void CollectionInfoBuilder::ImportRomDirectory(std::string path, CollectionInfo
     {
         std::string file = dirp[n]->d_name;
 
+        if ((file == "pgm.zip") || (file == "neogeo.zip"))
+            continue;
         // Check if the file is a directory or a file
         struct stat sb;
         if (romHierarchy && file != "." && file != ".." && stat( Utils::combinePath( path, file ).c_str(), &sb ) == 0 && S_ISDIR( sb.st_mode ))
diff --git a/RetroFE/Source/Graphics/Component/ReloadableScrollingText.cpp b/RetroFE/Source/Graphics/Component/ReloadableScrollingText.cpp
index 5b4f555..ebf92e9 100755
--- a/RetroFE/Source/Graphics/Component/ReloadableScrollingText.cpp
+++ b/RetroFE/Source/Graphics/Component/ReloadableScrollingText.cpp
@@ -27,140 +27,113 @@
 #include <iostream>
 #include <algorithm>
 
-
-ReloadableScrollingText::ReloadableScrollingText(Configuration &config, bool systemMode, 
-    bool layoutMode, bool menuMode, 
-    std::string type, std::string textFormat, std::string singlePrefix, 
-    std::string singlePostfix, std::string pluralPrefix, std::string pluralPostfix, 
-    std::string alignment, Page &p, int displayOffset, Font *font, 
-    float scaleX, float scaleY, std::string direction, float scrollingSpeed, 
-    float startPosition, float startTime, float endTime )
-
-    : Component(p)
-    , config_(config)
-    , systemMode_(systemMode)
-    , layoutMode_(layoutMode)
-    , menuMode_(menuMode)
-    , fontInst_(font)
-    , type_(type)
-    , textFormat_(textFormat)
-    , singlePrefix_(singlePrefix)
-    , singlePostfix_(singlePostfix)
-    , pluralPrefix_(pluralPrefix)
-    , pluralPostfix_(pluralPostfix)
-    , alignment_(alignment)
-    //, scaleX_(scaleX)
-    //, scaleY_(scaleY)
-	, scaleX_(1.0f)	//TODO
-	, scaleY_(1.0f)	//TODO
-    , direction_(direction)
-    , scrollingSpeed_(scrollingSpeed)
-    , startPosition_(startPosition)
-    , currentPosition_(-startPosition)
-    , startTime_(startTime)
-    , waitStartTime_(startTime)
-    , endTime_(endTime)
-    , waitEndTime_(0.0f)
-    , currentCollection_("")
-    , page_(NULL)
-    , displayOffset_(displayOffset)
-    , scrollForward_(true)
-    , needScrolling_(true)
-    , needRender_(false)
+ReloadableScrollingText::ReloadableScrollingText(Configuration &config, bool systemMode,
+                                                 bool layoutMode, bool menuMode,
+                                                 std::string type, std::string textFormat, std::string singlePrefix,
+                                                 std::string singlePostfix, std::string pluralPrefix, std::string pluralPostfix,
+                                                 std::string alignment, Page &p, int displayOffset, Font *font,
+                                                 float scaleX, float scaleY, std::string direction, float scrollingSpeed,
+                                                 float startPosition, float startTime, float endTime)
+
+    : Component(p), config_(config), systemMode_(systemMode), layoutMode_(layoutMode), menuMode_(menuMode), fontInst_(font), type_(type), textFormat_(textFormat), singlePrefix_(singlePrefix), singlePostfix_(singlePostfix), pluralPrefix_(pluralPrefix), pluralPostfix_(pluralPostfix), alignment_(alignment)
+      //, scaleX_(scaleX)
+      //, scaleY_(scaleY)
+      ,
+      scaleX_(1.0f) // TODO
+      ,
+      scaleY_(1.0f) // TODO
+      ,
+      direction_(direction), scrollingSpeed_(scrollingSpeed), startPosition_(startPosition), currentPosition_(-startPosition), startTime_(startTime), waitStartTime_(startTime), endTime_(endTime), waitEndTime_(0.0f), currentCollection_(""), page_(NULL), displayOffset_(displayOffset), scrollForward_(true), needScrolling_(true), needRender_(false)
 
 {
-    text_.clear( );
+    text_.clear();
 }
 
-
-ReloadableScrollingText::~ReloadableScrollingText( )
+ReloadableScrollingText::~ReloadableScrollingText()
 {
 }
 
-
 void ReloadableScrollingText::update(float dt)
 {
 
     // Scrolling process
-    if(needScrolling_){
+    if (needScrolling_)
+    {
         if (waitEndTime_ > 0)
-	{
-	    waitEndTime_ -= dt;
-	}
-	else if (waitStartTime_ > 0)
-	{
-	    waitStartTime_ -= dt;
-	}
-	else
-	{
-	  if (direction_ == "horizontal")
-	  {
-	      //currentPosition_ += scrollingSpeed_ * dt * scaleX_;
-	    currentPosition_ += (scrollForward_?1.0f:-1.0f) * scrollingSpeed_ * dt * scaleX_;
-
-	    // Sanity check
-	    if(currentPosition_ < -startPosition_ * scaleX_){
-	        currentPosition_ = -startPosition_ * scaleX_;
-	    }
-	  }
-	  else if (direction_ == "vertical")
-	  {
-	      currentPosition_ += scrollingSpeed_ * dt * scaleY_;
-	  }
-
-	  needRender_ = true;
-	}
+        {
+            waitEndTime_ -= dt;
+        }
+        else if (waitStartTime_ > 0)
+        {
+            waitStartTime_ -= dt;
+        }
+        else
+        {
+            if (direction_ == "horizontal")
+            {
+                // currentPosition_ += scrollingSpeed_ * dt * scaleX_;
+                currentPosition_ += (scrollForward_ ? 1.0f : -1.0f) * scrollingSpeed_ * dt * scaleX_;
+
+                // Sanity check
+                if (currentPosition_ < -startPosition_ * scaleX_)
+                {
+                    currentPosition_ = -startPosition_ * scaleX_;
+                }
+            }
+            else if (direction_ == "vertical")
+            {
+                currentPosition_ += scrollingSpeed_ * dt * scaleY_;
+            }
+
+            needRender_ = true;
+        }
     }
 
     // Reload media
-	if (newItemSelected)
-	{
-		reloadTexture();
-		newItemSelected       = false;
-	}
-	else if(newScrollItemSelected && getMenuScrollReload())
-	{
-		reloadTexture(true);
-		newScrollItemSelected = false;
-	}
+    if (newItemSelected)
+    {
+        reloadTexture();
+        newItemSelected = false;
+    }
+    else if (newScrollItemSelected && getMenuScrollReload())
+    {
+        reloadTexture(true);
+        newScrollItemSelected = false;
+    }
 
     Component::update(dt);
 }
 
-
-void ReloadableScrollingText::allocateGraphicsMemory( )
+void ReloadableScrollingText::allocateGraphicsMemory()
 {
-    Component::allocateGraphicsMemory( );
-    reloadTexture( );
+    Component::allocateGraphicsMemory();
+    reloadTexture();
 }
 
-
-void ReloadableScrollingText::freeGraphicsMemory( )
+void ReloadableScrollingText::freeGraphicsMemory()
 {
-    Component::freeGraphicsMemory( );
-    text_.clear( );
+    Component::freeGraphicsMemory();
+    text_.clear();
 }
 
-
-void ReloadableScrollingText::deInitializeFonts( )
+void ReloadableScrollingText::deInitializeFonts()
 {
-    fontInst_->deInitialize( );
+    fontInst_->deInitialize();
 }
 
-
-void ReloadableScrollingText::initializeFonts( )
+void ReloadableScrollingText::initializeFonts()
 {
-    fontInst_->initialize( );
+    fontInst_->initialize();
 }
 
-void ReloadableScrollingText::reloadTexture( )
+void ReloadableScrollingText::reloadTexture()
 {
-	reloadTexture(false);
+    reloadTexture(false);
 }
 
-void ReloadableScrollingText::reloadTexture( bool previousItem )
+void ReloadableScrollingText::reloadTexture(bool previousItem)
 {
-	needRender_ = true;
+    needRender_ = true;
 
     if (direction_ == "horizontal")
     {
@@ -170,54 +143,56 @@ void ReloadableScrollingText::reloadTexture( bool previousItem )
     {
         currentPosition_ = -startPosition_ * scaleY_;
     }
-    waitStartTime_   = startTime_;
-    waitEndTime_     = 0.0f;
+    waitStartTime_ = startTime_;
+    waitEndTime_ = 0.0f;
 
-    text_.clear( );
+    text_.clear();
 
     /* Select item to reload */
-	Item *selectedItem = NULL;
-	if(previousItem){
-		selectedItem = page.getPreviousSelectedItem(displayOffset_);
-	}
-	else{
-		selectedItem = page.getSelectedItem(displayOffset_);
-	}
-	if(!selectedItem) return;
+    Item *selectedItem = NULL;
+    if (previousItem)
+    {
+        selectedItem = page.getPreviousSelectedItem(displayOffset_);
+    }
+    else
+    {
+        selectedItem = page.getSelectedItem(displayOffset_);
+    }
+    if (!selectedItem)
+        return;
 
-    config_.getProperty( "currentCollection", currentCollection_ );
+    config_.getProperty("currentCollection", currentCollection_);
 
     // build clone list
     std::vector<std::string> names;
 
-    names.push_back( selectedItem->name );
-    names.push_back( selectedItem->fullTitle );
+    names.push_back(selectedItem->name);
+    names.push_back(selectedItem->fullTitle);
 
-    if (selectedItem->cloneof.length( ) > 0)
+    if (selectedItem->cloneof.length() > 0)
     {
-        names.push_back( selectedItem->cloneof );
+        names.push_back(selectedItem->cloneof);
     }
 
     // Check for corresponding .txt files
-    for (unsigned int n = 0; n < names.size( ) && text_.empty( ); ++n)
+    for (unsigned int n = 0; n < names.size() && text_.empty(); ++n)
     {
 
         std::string basename = names[n];
 
-        Utils::replaceSlashesWithUnderscores( basename );
+        Utils::replaceSlashesWithUnderscores(basename);
 
         if (systemMode_)
         {
 
             // check the master collection for the system artifact
-            loadText( collectionName, type_, type_, "", true );
+            loadText(collectionName, type_, type_, "", true);
 
             // check collection for the system artifact
-            if (text_.empty( ))
+            if (text_.empty())
             {
-              loadText( selectedItem->collectionInfo->name, type_, type_, "", true );
+                loadText(selectedItem->collectionInfo->name, type_, type_, "", true);
             }
-
         }
         else
         {
@@ -226,45 +201,42 @@ void ReloadableScrollingText::reloadTexture( bool previousItem )
             if (selectedItem->leaf) // item is a leaf
             {
 
-              // check the master collection for the artifact
-              loadText( collectionName, type_, basename, "", false );
-
-              // check the collection for the artifact
-              if (text_.empty( ))
-              {
-                loadText( selectedItem->collectionInfo->name, type_, basename, "", false );
-              }
+                // check the master collection for the artifact
+                loadText(collectionName, type_, basename, "", false);
 
+                // check the collection for the artifact
+                if (text_.empty())
+                {
+                    loadText(selectedItem->collectionInfo->name, type_, basename, "", false);
+                }
             }
             else // item is a submenu
             {
 
-              // check the master collection for the artifact
-              loadText( collectionName, type_, basename, "", false );
-
-              // check the collection for the artifact
-              if (text_.empty( ))
-              {
-                loadText( selectedItem->collectionInfo->name, type_, basename, "", false );
-              }
+                // check the master collection for the artifact
+                loadText(collectionName, type_, basename, "", false);
 
-              // check the submenu collection for the system artifact
-              if (text_.empty( ))
-              {
-                loadText( selectedItem->name, type_, type_, "", true );
-              }
+                // check the collection for the artifact
+                if (text_.empty())
+                {
+                    loadText(selectedItem->collectionInfo->name, type_, basename, "", false);
+                }
 
+                // check the submenu collection for the system artifact
+                if (text_.empty())
+                {
+                    loadText(selectedItem->name, type_, type_, "", true);
+                }
             }
-
         }
     }
 
     // Check for thext in the roms directory
-    if ( text_.empty( ))
-        loadText( selectedItem->filepath, type_, type_, selectedItem->filepath, false );
+    if (text_.empty())
+        loadText(selectedItem->filepath, type_, type_, selectedItem->filepath, false);
 
     // Check for supported fields if text is still empty
-    if (text_.empty( ))
+    if (text_.empty())
     {
         std::stringstream ss;
         std::string text = "";
@@ -295,15 +267,15 @@ void ReloadableScrollingText::reloadTexture( bool previousItem )
         else if (type_ == "year")
         {
             if (selectedItem->leaf) // item is a leaf
-              text = selectedItem->year;
+                text = selectedItem->year;
             else // item is a collection
-              (void)config_.getProperty("collections." + selectedItem->name + ".year", text );
+                (void)config_.getProperty("collections." + selectedItem->name + ".year", text);
         }
         else if (type_ == "title")
         {
             text = selectedItem->title;
         }
-        else if(type_ == "developer")
+        else if (type_ == "developer")
         {
             text = selectedItem->developer;
             // Overwrite in case developer has not been specified
@@ -315,16 +287,16 @@ void ReloadableScrollingText::reloadTexture( bool previousItem )
         else if (type_ == "manufacturer")
         {
             if (selectedItem->leaf) // item is a leaf
-              text = selectedItem->manufacturer;
+                text = selectedItem->manufacturer;
             else // item is a collection
-              (void)config_.getProperty("collections." + selectedItem->name + ".manufacturer", text );
+                (void)config_.getProperty("collections." + selectedItem->name + ".manufacturer", text);
         }
         else if (type_ == "genre")
         {
             if (selectedItem->leaf) // item is a leaf
-              text = selectedItem->genre;
+                text = selectedItem->genre;
             else // item is a collection
-              (void)config_.getProperty("collections." + selectedItem->name + ".genre", text );
+                (void)config_.getProperty("collections." + selectedItem->name + ".genre", text);
         }
         else if (type_ == "playlist")
         {
@@ -332,7 +304,7 @@ void ReloadableScrollingText::reloadTexture( bool previousItem )
         }
         else if (type_ == "firstLetter")
         {
-          text = selectedItem->fullTitle.at(0);
+            text = selectedItem->fullTitle.at(0);
         }
         else if (type_ == "collectionName")
         {
@@ -357,35 +329,35 @@ void ReloadableScrollingText::reloadTexture( bool previousItem )
         {
             if (page.getSelectedIndex() == 0)
             {
-                ss << singlePrefix_ << (page.getSelectedIndex()+1) << pluralPostfix_;
+                ss << singlePrefix_ << (page.getSelectedIndex() + 1) << pluralPostfix_;
             }
             else if (page.getSelectedIndex() == 1)
             {
-                ss << singlePrefix_ << (page.getSelectedIndex()+1) << singlePostfix_;
+                ss << singlePrefix_ << (page.getSelectedIndex() + 1) << singlePostfix_;
             }
             else
             {
-                ss << pluralPrefix_ << (page.getSelectedIndex()+1) << pluralPostfix_;
+                ss << pluralPrefix_ << (page.getSelectedIndex() + 1) << pluralPostfix_;
             }
         }
         else if (type_ == "collectionIndexSize")
         {
             if (page.getSelectedIndex() == 0)
             {
-                ss << singlePrefix_ << (page.getSelectedIndex()+1) << "/" << page.getCollectionSize() << pluralPostfix_;
+                ss << singlePrefix_ << (page.getSelectedIndex() + 1) << "/" << page.getCollectionSize() << pluralPostfix_;
             }
             else if (page.getSelectedIndex() == 1)
             {
-                ss << singlePrefix_ << (page.getSelectedIndex()+1) << "/" << page.getCollectionSize() << singlePostfix_;
+                ss << singlePrefix_ << (page.getSelectedIndex() + 1) << "/" << page.getCollectionSize() << singlePostfix_;
             }
             else
             {
-                ss << pluralPrefix_ << (page.getSelectedIndex()+1) << "/" << page.getCollectionSize() << pluralPostfix_;
+                ss << pluralPrefix_ << (page.getSelectedIndex() + 1) << "/" << page.getCollectionSize() << pluralPostfix_;
             }
         }
         else if (!selectedItem->leaf) // item is not a leaf
         {
-            (void)config_.getProperty("collections." + selectedItem->name + "." + type_, text );
+            (void)config_.getProperty("collections." + selectedItem->name + "." + type_, text);
         }
 
         if (text == "0")
@@ -420,40 +392,45 @@ void ReloadableScrollingText::reloadTexture( bool previousItem )
     needScrolling_ = true;
 
     // For horizontal images, determine if text needs scrolling
-    if (direction_ == "horizontal"){
+    if (direction_ == "horizontal")
+    {
         Font *font;
         if (baseViewInfo.font) // Use font of this specific item if available
             font = baseViewInfo.font;
-        else                   // If not, use the general font settings
+        else // If not, use the general font settings
             font = fontInst_;
 
-	int imageWidth = 0, curLineWidth;
+        int imageWidth = 0, curLineWidth;
 
-	for (unsigned int l = 0; l < text_.size( ); ++l)
-	{
-	    curLineWidth = 0;
+        for (unsigned int l = 0; l < text_.size(); ++l)
+        {
+            curLineWidth = 0;
 
-	    for (unsigned int i = 0; i < text_[l].size( ); ++i)
-	    {
-	        Font::GlyphInfo glyph;
-		if (font->getRect( text_[l][i], glyph ))
-		{
-		  if ( glyph.minX < 0 )
-		  {
-		      curLineWidth += glyph.minX;
-		  }
+            for (unsigned int i = 0; i < text_[l].size();)
+            {
+                Font::GlyphInfoBuild *info;
+                unsigned int charCode;
 
-		  int char_width = static_cast<int>( glyph.rect.w?glyph.rect.w:glyph.advance );
-		  curLineWidth += char_width;
+                i += font->utf8ToUcs2(&text_[l][i], &charCode);
 
-		  //printf("char=%c, char_width = %d, curLineWidth = %d\n", text_[l][i], char_width, curLineWidth);
-		}
-	    }
+                if (font->getGlyphBuild(charCode, &info))
+                {
+                    if (info->glyph.minX < 0)
+                    {
+                        curLineWidth += info->glyph.minX;
+                    }
 
-	    imageWidth = (curLineWidth > imageWidth) ? curLineWidth : imageWidth;
-	}
+                    int char_width = static_cast<int>(info->glyph.rect.w ? info->glyph.rect.w : info->glyph.advance);
+                    curLineWidth += char_width;
 
-        float imageMaxWidth  = 0;
+                    // printf("char=%c, char_width = %d, curLineWidth = %d\n", text_[l][i], char_width, curLineWidth);
+                }
+            }
+
+            imageWidth = (curLineWidth > imageWidth) ? curLineWidth : imageWidth;
+        }
+
+        float imageMaxWidth = 0;
         if (baseViewInfo.Width < baseViewInfo.MaxWidth && baseViewInfo.Width > 0)
         {
             imageMaxWidth = baseViewInfo.Width;
@@ -463,17 +440,16 @@ void ReloadableScrollingText::reloadTexture( bool previousItem )
             imageMaxWidth = baseViewInfo.MaxWidth;
         }
 
-        //printf("imageWidth * scaleX_ - currentPosition_ = %f, imageMaxWidth = %f\n", imageWidth * scaleX_ - currentPosition_, imageMaxWidth);
+        // printf("imageWidth * scaleX_ - currentPosition_ = %f, imageMaxWidth = %f\n", imageWidth * scaleX_ - currentPosition_, imageMaxWidth);
 
-	if ( imageWidth * scaleX_ - currentPosition_ <= imageMaxWidth )
-	{
-	    needScrolling_ = false;
-	}
+        if (imageWidth * scaleX_ - currentPosition_ <= imageMaxWidth)
+        {
+            needScrolling_ = false;
+        }
     }
 }
 
-
-void ReloadableScrollingText::loadText( std::string collection, std::string type, std::string basename, std::string filepath, bool systemMode )
+void ReloadableScrollingText::loadText(std::string collection, std::string type, std::string basename, std::string filepath, bool systemMode)
 {
 
     std::string textPath = "";
@@ -483,7 +459,7 @@ void ReloadableScrollingText::loadText( std::string collection, std::string type
     {
         std::string layoutName;
         config_.getProperty("layout", layoutName);
-        textPath = Utils::combinePath(Configuration::isUserLayout_?Configuration::userPath:Configuration::absolutePath, "layouts", layoutName, "collections", collection);
+        textPath = Utils::combinePath(Configuration::isUserLayout_ ? Configuration::userPath : Configuration::absolutePath, "layouts", layoutName, "collections", collection);
         if (systemMode)
             textPath = Utils::combinePath(textPath, "system_artwork");
         else
@@ -491,28 +467,28 @@ void ReloadableScrollingText::loadText( std::string collection, std::string type
     }
     else
     {
-        config_.getMediaPropertyAbsolutePath( collection, type, systemMode, textPath );
+        config_.getMediaPropertyAbsolutePath(collection, type, systemMode, textPath);
     }
-    if ( filepath != "" )
+    if (filepath != "")
         textPath = filepath;
 
-    textPath = Utils::combinePath( textPath, basename );
+    textPath = Utils::combinePath(textPath, basename);
 
     textPath += ".txt";
 
-    std::ifstream includeStream( textPath.c_str( ) );
+    std::ifstream includeStream(textPath.c_str());
 
-    if (!includeStream.good( ))
+    if (!includeStream.good())
     {
         return;
     }
 
     std::string line;
 
-    while(std::getline(includeStream, line))
+    while (std::getline(includeStream, line))
     {
         // In horizontal scrolling direction, add a space before every line except the first.
-        if (direction_ == "horizontal" && !text_.empty( ))
+        if (direction_ == "horizontal" && !text_.empty())
         {
             line = " " + line;
         }
@@ -527,33 +503,28 @@ void ReloadableScrollingText::loadText( std::string collection, std::string type
             std::transform(line.begin(), line.end(), line.begin(), ::tolower);
         }
 
-        text_.push_back( line );
-
+        text_.push_back(line);
     }
 
     return;
-
 }
 
-
-void ReloadableScrollingText::draw( )
+void ReloadableScrollingText::draw()
 {
-    Component::draw( );
+    Component::draw();
 
-    if (!text_.empty( ) && baseViewInfo.Alpha > 0.0f)
+    if (!text_.empty() && baseViewInfo.Alpha > 0.0f)
     {
 
         Font *font;
         if (baseViewInfo.font) // Use font of this specific item if available
-          font = baseViewInfo.font;
-        else                   // If not, use the general font settings
-          font = fontInst_;
-
-        SDL_Surface *t = font->getTexture( );
+            font = baseViewInfo.font;
+        else // If not, use the general font settings
+            font = fontInst_;
 
         float imageHeight = 0;
-        float imageWidth     = 0;
-        float imageMaxWidth  = 0;
+        float imageWidth = 0;
+        float imageMaxWidth = 0;
         float imageMaxHeight = 0;
         if (baseViewInfo.Width < baseViewInfo.MaxWidth && baseViewInfo.Width > 0)
         {
@@ -572,67 +543,68 @@ void ReloadableScrollingText::draw( )
             imageMaxHeight = baseViewInfo.MaxHeight;
         }
 
-        imageHeight = (float)font->getHeight( );
+        imageHeight = (float)font->getHeight();
 
-        //float scale = (float)baseViewInfo.FontSize / (float)font->getHeight( ) / scaleY_;
-        //TODO, modify for scaling - for now, no scaling in effect
+        // float scale = (float)baseViewInfo.FontSize / (float)font->getHeight( ) / scaleY_;
+        // TODO, modify for scaling - for now, no scaling in effect
         float scale = 1.0f;
 
-
         // Horizontal mode only:
         // Compute image width that fits inside the the container width to get the origin position
         if (direction_ == "horizontal")
         {
-	    for ( unsigned int i = 0; i < text_[0].size( ); ++i )
-	    {
-	        Font::GlyphInfo glyph;
-		if ( font->getRect( text_[0][i], glyph ) )
-		{
-		    if ( glyph.minX < 0 )
-		    {
-		        imageWidth += glyph.minX;
-		    }
-
-                    int char_width = static_cast<int>( glyph.rect.w?glyph.rect.w:glyph.advance );
-
-		    if ( (imageWidth + char_width) * scale * scaleX_ > imageMaxWidth )
-		    {
-		        break;
-		    }
-		    imageWidth  += char_width;
-
-		    /*printf("textData_[%d]=%c, glyph.advance= %f - %d\n", i, textData_[i], glyph.advance, glyph.advance);
-		      printf("imageWidth=%f \n", imageWidth);*/
-		}
-		else{
-		    /*std::stringstream ss;
-		      ss << "Could not find Glyph info for char: " << textData_[i];
-		      Logger::write(Logger::ZONE_WARNING, "Text", ss.str());*/
-		}
-	    }
-        }
-
-        float oldWidth       = baseViewInfo.Width;
-        float oldHeight      = baseViewInfo.Height;
-        float oldImageWidth  = baseViewInfo.ImageHeight;
-        float oldImageHeight = baseViewInfo.ImageWidth;
+            for (unsigned int i = 0; i < text_[0].size();)
+            {
+                Font::GlyphInfoBuild *info;
+                unsigned int charCode;
 
-        baseViewInfo.Width       = imageWidth*scale;
-        baseViewInfo.Height      = baseViewInfo.FontSize;
-        baseViewInfo.ImageWidth  = imageWidth;
-        baseViewInfo.ImageHeight = imageHeight;
+                i += font->utf8ToUcs2(&text_[0][i], &charCode);
 
-        float xOrigin = baseViewInfo.XRelativeToOrigin( );
-        float yOrigin = baseViewInfo.YRelativeToOrigin( );
-        //printf("IN SCROLLABLE_TEXT - xOrigin=%f, yOrigin=%f, imageWidth=%f\n", xOrigin, yOrigin, imageWidth);
+                if (font->getGlyphBuild(charCode, &info))
+                {
+                    if (info->glyph.minX < 0)
+                    {
+                        imageWidth += info->glyph.minX;
+                    }
 
-        baseViewInfo.Width       = oldWidth;
-        baseViewInfo.Height      = oldHeight;
-        baseViewInfo.ImageWidth  = oldImageWidth;
-        baseViewInfo.ImageHeight = oldImageHeight;
+                    int char_width = static_cast<int>(info->glyph.rect.w ? info->glyph.rect.w : info->glyph.advance);
+
+                    if ((imageWidth + char_width) * scale * scaleX_ > imageMaxWidth)
+                    {
+                        break;
+                    }
+                    imageWidth += char_width;
 
+                    /*printf("textData_[%d]=%c, glyph.advance= %f - %d\n", i, textData_[i], glyph.advance, glyph.advance);
+                      printf("imageWidth=%f \n", imageWidth);*/
+                }
+                else
+                {
+                    /*std::stringstream ss;
+                      ss << "Could not find Glyph info for char: " << textData_[i];
+                      Logger::write(Logger::ZONE_WARNING, "Text", ss.str());*/
+                }
+            }
+        }
 
+        float oldWidth = baseViewInfo.Width;
+        float oldHeight = baseViewInfo.Height;
+        float oldImageWidth = baseViewInfo.ImageHeight;
+        float oldImageHeight = baseViewInfo.ImageWidth;
 
+        baseViewInfo.Width = imageWidth * scale;
+        baseViewInfo.Height = baseViewInfo.FontSize;
+        baseViewInfo.ImageWidth = imageWidth;
+        baseViewInfo.ImageHeight = imageHeight;
+
+        float xOrigin = baseViewInfo.XRelativeToOrigin();
+        float yOrigin = baseViewInfo.YRelativeToOrigin();
+        // printf("IN SCROLLABLE_TEXT - xOrigin=%f, yOrigin=%f, imageWidth=%f\n", xOrigin, yOrigin, imageWidth);
+
+        baseViewInfo.Width = oldWidth;
+        baseViewInfo.Height = oldHeight;
+        baseViewInfo.ImageWidth = oldImageWidth;
+        baseViewInfo.ImageHeight = oldImageHeight;
 
         SDL_Rect rect;
         float position = 0.0f;
@@ -640,130 +612,136 @@ void ReloadableScrollingText::draw( )
         if (direction_ == "horizontal")
         {
 
-            rect.x = static_cast<int>( xOrigin );
+            rect.x = static_cast<int>(xOrigin);
 
             if (currentPosition_ < 0)
             {
-                rect.x -= static_cast<int>( currentPosition_ );
+                rect.x -= static_cast<int>(currentPosition_);
             }
 
-            for (unsigned int l = 0; l < text_.size( ); ++l)
+            for (unsigned int l = 0; l < text_.size(); ++l)
             {
-                for (unsigned int i = 0; i < text_[l].size( ); ++i)
+                for (unsigned int i = 0; i < text_[l].size();)
                 {
 
                     // Do not print outside the box
-                    if (rect.x >= (static_cast<int>( xOrigin ) + imageMaxWidth))
+                    if (rect.x >= (static_cast<int>(xOrigin) + imageMaxWidth))
                     {
                         break;
                     }
 
-                    Font::GlyphInfo glyph;
+                    // printf("text_[%d][%d] = %c, 0x%02X\n", l, i, text_[l][i], text_[l][i]);
 
-                    //printf("text_[%d][%d] = %c, 0x%02X\n", l, i, text_[l][i], text_[l][i]);
+                    Font::GlyphInfoBuild *info;
+                    unsigned int charCode;
 
-                    //if (font->getRect( text_[l][i], glyph) && glyph.rect.h > 0)
-                    if (font->getRect( text_[l][i], glyph))
+                    i += font->utf8ToUcs2(&text_[l][i], &charCode);
+
+                    if (font->getGlyphBuild(charCode, &info))
                     {
-                        SDL_Rect charRect = glyph.rect;
-                        rect.h  = static_cast<int>( charRect.h * scale * scaleY_ );
-                        int char_width = static_cast<int>( charRect.w?charRect.w:glyph.advance );
-                        rect.w  = static_cast<int>( char_width * scale * scaleX_ );
-                        rect.y  = static_cast<int>( yOrigin );
+                        SDL_Rect charRect = info->glyph.rect;
+                        rect.h = static_cast<int>(charRect.h * scale * scaleY_);
+                        int char_width = static_cast<int>(charRect.w ? charRect.w : info->glyph.advance);
+                        rect.w = static_cast<int>(char_width * scale * scaleX_);
+                        rect.y = static_cast<int>(yOrigin);
 
                         /*if (font->getAscent( ) < glyph.maxY)
                         {
                             rect.y += static_cast<int>( (font->getAscent( ) - glyph.maxY) * scale * scaleY_ );
                         }*/
-                        rect.y += static_cast<int>( (font->getAscent( ) - glyph.maxY) * scale * scaleY_ );
+                        rect.y += static_cast<int>((font->getAscent() - info->glyph.maxY) * scale * scaleY_);
 
                         // Check if glyph falls partially outside the box at the back end
-                        if ((rect.x + static_cast<int>( char_width * scale * scaleX_ )) >= (static_cast<int>( xOrigin ) + imageMaxWidth))
+                        if ((rect.x + static_cast<int>(char_width * scale * scaleX_)) >= (static_cast<int>(xOrigin) + imageMaxWidth))
                         {
-                            rect.w     = static_cast<int>( xOrigin ) + static_cast<int>( imageMaxWidth ) - rect.x;
-                            charRect.w = static_cast<int>( rect.w / scale / scaleX_ );
+                            rect.w = static_cast<int>(xOrigin) + static_cast<int>(imageMaxWidth) - rect.x;
+                            charRect.w = static_cast<int>(rect.w / scale / scaleX_);
                         }
 
                         // Print the glyph if it falls (partially) within the box
-                        if ( position + char_width * scale * scaleX_ > currentPosition_ )
+                        if (position + char_width * scale * scaleX_ > currentPosition_)
                         {
                             // Check if glyph falls partially outside the box at the front end
-                            if ( position < currentPosition_ )
+                            if (position < currentPosition_)
                             {
-                                rect.w     = static_cast<int>( char_width * scale * scaleX_ + position - currentPosition_ );
-                                charRect.x = static_cast<int>( charRect.x + charRect.w - rect.w / scale / scaleX_ );
-                                charRect.w = static_cast<int>( rect.w / scale / scaleX_ );
+                                rect.w = static_cast<int>(char_width * scale * scaleX_ + position - currentPosition_);
+                                charRect.x = static_cast<int>(charRect.x + charRect.w - rect.w / scale / scaleX_);
+                                charRect.w = static_cast<int>(rect.w / scale / scaleX_);
                             }
                             if (rect.w > 0)
                             {
-                                SDL::renderCopy(t, baseViewInfo.Alpha, &charRect, &rect, baseViewInfo);
+                                SDL::renderCopy(info->surface, baseViewInfo.Alpha, &charRect, &rect, baseViewInfo);
                                 rect.x += rect.w;
                             }
-                            else if ((rect.x + static_cast<int>( char_width * scale * scaleX_ )) >= (static_cast<int>( xOrigin ) + imageMaxWidth))
+                            else if ((rect.x + static_cast<int>(char_width * scale * scaleX_)) >= (static_cast<int>(xOrigin) + imageMaxWidth))
                             {
-                                rect.x = static_cast<int>( xOrigin ) + static_cast<int>( imageMaxWidth ) + 10; // Stop handling the rest of the string
+                                rect.x = static_cast<int>(xOrigin) + static_cast<int>(imageMaxWidth) + 10; // Stop handling the rest of the string
                             }
                             /*else{
-			        rect.x += glyph.advance * scale * scaleX_;
+                    rect.x += glyph.advance * scale * scaleX_;
                             }*/
                         }
                         position += char_width * scale * scaleX_;
-
                     }
                 }
             }
 
             // Scrolling process
-            if(needScrolling_){
-
-	        // Determine image width
-	        int imageWidth = 0, curLineWidth, char_width;
-
-		for (unsigned int l = 0; l < text_.size( ); ++l)
-		{
-		    curLineWidth = 0;
-
-		    for (unsigned int i = 0; i < text_[l].size( ); ++i)
-		    {
-		        Font::GlyphInfo glyph;
-			if (font->getRect( text_[l][i], glyph ))
-			{
-			    if ( glyph.minX < 0 )
-			    {
-			        curLineWidth += glyph.minX;
-			    }
-
-			    char_width = static_cast<int>( glyph.rect.w?glyph.rect.w:glyph.advance );
-			    curLineWidth += char_width;
-			}
-		    }
-
-		    imageWidth = (curLineWidth > imageWidth) ? curLineWidth : imageWidth;
-		}
-
-		// Add right padding of one char width
-		imageWidth += char_width;
-
-		//printf("in Draw imageWidth * scaleX_ - currentPosition_ = %f, imageMaxWidth = %f\n", imageWidth * scaleX_ - currentPosition_, imageMaxWidth);
-
-		// Reset scrolling position when we're done
-		if (scrollForward_ &&
-		    waitStartTime_ <= 0 &&
-		    imageWidth * scale * scaleX_ - currentPosition_ <= imageMaxWidth)
-		{
-		    waitEndTime_     = endTime_;
-		    scrollForward_ = false;
-		    needRender_ = true;
-		}
-		else if(!scrollForward_ &&
-			waitEndTime_ <= 0 &&
-			currentPosition_ <= -startPosition_ * scaleX_)
-		{
-		  waitStartTime_   = startTime_;
-		  currentPosition_ = -startPosition_ * scaleX_;
-		  scrollForward_ = true;
-		  needRender_ = true;
-		}
+            if (needScrolling_)
+            {
+
+                // Determine image width
+                int imageWidth = 0, curLineWidth, char_width;
+
+                for (unsigned int l = 0; l < text_.size(); ++l)
+                {
+                    curLineWidth = 0;
+
+                    for (unsigned int i = 0; i < text_[l].size();)
+                    {
+                        Font::GlyphInfoBuild *info;
+                        unsigned int charCode;
+
+                        i += font->utf8ToUcs2(&text_[l][i], &charCode);
+
+                        if (font->getGlyphBuild(charCode, &info))
+                        {
+                            if (info->glyph.minX < 0)
+                            {
+                                curLineWidth += info->glyph.minX;
+                            }
+
+                            char_width = static_cast<int>(info->glyph.rect.w ? info->glyph.rect.w : info->glyph.advance);
+                            curLineWidth += char_width;
+                        }
+                    }
+
+                    imageWidth = (curLineWidth > imageWidth) ? curLineWidth : imageWidth;
+                }
+
+                // Add right padding of one char width
+                imageWidth += char_width;
+
+                // printf("in Draw imageWidth * scaleX_ - currentPosition_ = %f, imageMaxWidth = %f\n", imageWidth * scaleX_ - currentPosition_, imageMaxWidth);
+
+                // Reset scrolling position when we're done
+                if (scrollForward_ &&
+                    waitStartTime_ <= 0 &&
+                    imageWidth * scale * scaleX_ - currentPosition_ <= imageMaxWidth)
+                {
+                    waitEndTime_ = endTime_;
+                    scrollForward_ = false;
+                    needRender_ = true;
+                }
+                else if (!scrollForward_ &&
+                         waitEndTime_ <= 0 &&
+                         currentPosition_ <= -startPosition_ * scaleX_)
+                {
+                    waitStartTime_ = startTime_;
+                    currentPosition_ = -startPosition_ * scaleX_;
+                    scrollForward_ = true;
+                    needRender_ = true;
+                }
             }
         }
         else if (direction_ == "vertical")
@@ -771,48 +749,52 @@ void ReloadableScrollingText::draw( )
 
             unsigned int spaceWidth = 0;
             {
-                Font::GlyphInfo glyph;
-                if (font->getRect( ' ', glyph) )
+                Font::GlyphInfoBuild *info;
+                if (font->getGlyphBuild(' ', &info))
                 {
-                    spaceWidth = static_cast<int>( glyph.advance * scale * scaleX_);
+                    spaceWidth = static_cast<int>(info->glyph.advance * scale * scaleX_);
                 }
             }
 
             // Reformat the text based on the image width
-            std::vector<std::string>  text;
+            std::vector<std::string> text;
             std::vector<unsigned int> textWords;
             std::vector<unsigned int> textWidth;
-            std::vector<bool>         textLast;
-            for (unsigned int l = 0; l < text_.size( ); ++l)
+            std::vector<bool> textLast;
+            for (unsigned int l = 0; l < text_.size(); ++l)
             {
-                std::string        line = "";
+                std::string line = "";
                 std::istringstream iss(text_[l]);
-                std::string        word;
-                unsigned int       width     = 0;
-                unsigned int       lineWidth = 0;
-                unsigned int       wordCount = 0;
+                std::string word;
+                unsigned int width = 0;
+                unsigned int lineWidth = 0;
+                unsigned int wordCount = 0;
                 while (iss >> word)
                 {
 
                     // Determine word image width
                     unsigned int wordWidth = 0;
-                    for (unsigned int i = 0; i < word.size( ); ++i)
+                    for (unsigned int i = 0; i < word.size();)
                     {
-                        Font::GlyphInfo glyph;
-                        if (font->getRect( word[i], glyph) )
+                        Font::GlyphInfoBuild *info;
+                        unsigned int charCode;
+
+                        i += font->utf8ToUcs2(&word[i], &charCode);
+
+                        if (font->getGlyphBuild(charCode, &info))
                         {
-                            wordWidth += static_cast<int>( glyph.advance * scale * scaleX_ );
+                            wordWidth += static_cast<int>(info->glyph.advance * scale * scaleX_);
                         }
                     }
                     // Determine if the word will fit on the line
                     if (width > 0 && (width + spaceWidth + wordWidth > imageMaxWidth))
                     {
-                        text.push_back( line );
-                        textWords.push_back( wordCount );
-                        textWidth.push_back( lineWidth );
-                        textLast.push_back( false );
-                        line      = word;
-                        width     = wordWidth;
+                        text.push_back(line);
+                        textWords.push_back(wordCount);
+                        textWidth.push_back(lineWidth);
+                        textLast.push_back(false);
+                        line = word;
+                        width = wordWidth;
                         lineWidth = wordWidth;
                         wordCount = 1;
                     }
@@ -820,12 +802,12 @@ void ReloadableScrollingText::draw( )
                     {
                         if (width == 0)
                         {
-                            line  += word;
+                            line += word;
                             width += wordWidth;
                         }
                         else
                         {
-                            line  += " " + word;
+                            line += " " + word;
                             width += spaceWidth + wordWidth;
                         }
                         lineWidth += wordWidth;
@@ -834,97 +816,98 @@ void ReloadableScrollingText::draw( )
                 }
                 if (text_[l] == "" || line != "")
                 {
-                    text.push_back( line );
-                    textWords.push_back( wordCount );
-                    textWidth.push_back( lineWidth );
-                    textLast.push_back( true );
-                    width     = 0;
+                    text.push_back(line);
+                    textWords.push_back(wordCount);
+                    textWidth.push_back(lineWidth);
+                    textLast.push_back(true);
+                    width = 0;
                     lineWidth = 0;
                     wordCount = 0;
                 }
             }
 
-
             // Print reformatted text
-            rect.y = static_cast<int>( yOrigin );
+            rect.y = static_cast<int>(yOrigin);
 
             if (currentPosition_ < 0)
             {
-                rect.y -= static_cast<int>( currentPosition_ );
+                rect.y -= static_cast<int>(currentPosition_);
             }
 
             // Do not scroll if the text fits fully inside the box, and start position is 0
-            if (text.size() * font->getHeight( ) * scale * scaleY_ <= imageMaxHeight && startPosition_ == 0.0f)
+            if (text.size() * font->getHeight() * scale * scaleY_ <= imageMaxHeight && startPosition_ == 0.0f)
             {
                 currentPosition_ = 0.0f;
-                waitStartTime_   = 0.0f;
-                waitEndTime_     = 0.0f;
+                waitStartTime_ = 0.0f;
+                waitEndTime_ = 0.0f;
             }
 
-            for (unsigned int l = 0; l < text.size( ); ++l)
+            for (unsigned int l = 0; l < text.size(); ++l)
             {
 
                 // Do not print outside the box
-                if (rect.y >= (static_cast<int>( yOrigin ) + imageMaxHeight))
+                if (rect.y >= (static_cast<int>(yOrigin) + imageMaxHeight))
                 {
                     break;
                 }
 
                 // Define x coordinate
-                rect.x = static_cast<int>( xOrigin );
+                rect.x = static_cast<int>(xOrigin);
                 if (alignment_ == "right")
                 {
-                    rect.x = static_cast<int>( xOrigin + imageMaxWidth - textWidth[l] - (textWords[l] - 1) * spaceWidth * scale * scaleX_ );
+                    rect.x = static_cast<int>(xOrigin + imageMaxWidth - textWidth[l] - (textWords[l] - 1) * spaceWidth * scale * scaleX_);
                 }
                 if (alignment_ == "centered")
                 {
-                    rect.x = static_cast<int>( xOrigin + imageMaxWidth / 2 - textWidth[l] / 2 - (textWords[l] - 1) * spaceWidth * scale * scaleX_ / 2 );
+                    rect.x = static_cast<int>(xOrigin + imageMaxWidth / 2 - textWidth[l] / 2 - (textWords[l] - 1) * spaceWidth * scale * scaleX_ / 2);
                 }
 
                 std::istringstream iss(text[l]);
-                std::string        word;
-                unsigned int       wordCount = textWords[l];
-                unsigned int       spaceFill = static_cast<int>( imageMaxWidth ) - textWidth[l];
-                unsigned int       yAdvance  = static_cast<int>( font->getHeight( ) * scale * scaleY_ );
+                std::string word;
+                unsigned int wordCount = textWords[l];
+                unsigned int spaceFill = static_cast<int>(imageMaxWidth) - textWidth[l];
+                unsigned int yAdvance = static_cast<int>(font->getHeight() * scale * scaleY_);
                 while (iss >> word)
                 {
 
-                    for (unsigned int i = 0; i < word.size( ); ++i)
+                    for (unsigned int i = 0; i < word.size();)
                     {
-                        Font::GlyphInfo glyph;
+                        Font::GlyphInfoBuild *info;
+                        unsigned int charCode;
+
+                        i += font->utf8ToUcs2(&word[i], &charCode);
 
-                        //if (font->getRect( word[i], glyph) && glyph.rect.h > 0)
-                        if (font->getRect( word[i], glyph))
+                        if (font->getGlyphBuild(charCode, &info))
                         {
-                            SDL_Rect charRect = glyph.rect;
-                            rect.h   = static_cast<int>( charRect.h * scale * scaleY_ );
-                            rect.w   = static_cast<int>( charRect.w * scale * scaleX_ );
-                            yAdvance = static_cast<int>( font->getHeight( ) * scale * scaleY_ );
+                            SDL_Rect charRect = info->glyph.rect;
+                            rect.h = static_cast<int>(charRect.h * scale * scaleY_);
+                            rect.w = static_cast<int>(charRect.w * scale * scaleX_);
+                            yAdvance = static_cast<int>(font->getHeight() * scale * scaleY_);
 
                             // Check if glyph falls partially outside the box at the bottom end
-                            if ((rect.y + rect.h) >= (static_cast<int>( yOrigin ) + imageMaxHeight))
+                            if ((rect.y + rect.h) >= (static_cast<int>(yOrigin) + imageMaxHeight))
                             {
-                                rect.h     = static_cast<int>( yOrigin ) + static_cast<int>( imageMaxHeight ) - rect.y;
-                                charRect.h = static_cast<int>( rect.h / scale / scaleY_ );
+                                rect.h = static_cast<int>(yOrigin) + static_cast<int>(imageMaxHeight) - rect.y;
+                                charRect.h = static_cast<int>(rect.h / scale / scaleY_);
                             }
 
                             // Print the glyph if it falls (partially) within the box
-                            if ( position + font->getHeight( ) * scale * scaleY_ > currentPosition_ )
+                            if (position + font->getHeight() * scale * scaleY_ > currentPosition_)
                             {
                                 // Check if glyph falls partially outside the box at the front end
-                                if ( position < currentPosition_ )
+                                if (position < currentPosition_)
                                 {
-                                    yAdvance  -= rect.h - static_cast<int>( font->getHeight( ) * scale * scaleX_ + position - currentPosition_ );
-                                    rect.h     = static_cast<int>( font->getHeight( ) * scale * scaleX_ + position - currentPosition_ );
-                                    charRect.y = static_cast<int>( charRect.y + charRect.h - rect.h / scale / scaleX_ );
-                                    charRect.h = static_cast<int>( rect.h / scale / scaleX_ );
+                                    yAdvance -= rect.h - static_cast<int>(font->getHeight() * scale * scaleX_ + position - currentPosition_);
+                                    rect.h = static_cast<int>(font->getHeight() * scale * scaleX_ + position - currentPosition_);
+                                    charRect.y = static_cast<int>(charRect.y + charRect.h - rect.h / scale / scaleX_);
+                                    charRect.h = static_cast<int>(rect.h / scale / scaleX_);
                                 }
                                 if (rect.h > 0)
                                 {
-                                    SDL::renderCopy(t, baseViewInfo.Alpha, &charRect, &rect, baseViewInfo);
+                                    SDL::renderCopy(info->surface, baseViewInfo.Alpha, &charRect, &rect, baseViewInfo);
                                 }
                             }
-                            rect.x += static_cast<int>( glyph.advance * scale * scaleX_ );
+                            rect.x += static_cast<int>(info->glyph.advance * scale * scaleX_);
                         }
                     }
 
@@ -932,62 +915,60 @@ void ReloadableScrollingText::draw( )
                     wordCount -= 1;
                     if (wordCount > 0 && !textLast[l] && alignment_ == "justified")
                     {
-                        unsigned int advance = static_cast<int>( spaceFill / wordCount );
+                        unsigned int advance = static_cast<int>(spaceFill / wordCount);
                         spaceFill -= advance;
-                        rect.x    += advance;
+                        rect.x += advance;
                     }
                     else
                     {
-                        rect.x += static_cast<int>( spaceWidth );
+                        rect.x += static_cast<int>(spaceWidth);
                     }
                 }
 
                 // Handle scrolling of empty lines
                 if (text[l] == "")
                 {
-                    Font::GlyphInfo glyph;
-
-                    if (font->getRect( ' ', glyph) && glyph.rect.h > 0)
+                    Font::GlyphInfoBuild *info;
+                    if (font->getGlyphBuild(' ', &info) && info->glyph.rect.h > 0)
                     {
-                        rect.h   = static_cast<int>( glyph.rect.h * scale * scaleY_ );
+                        rect.h = static_cast<int>(info->glyph.rect.h * scale * scaleY_);
 
                         // Check if the glyph falls (partially) within the box at the front end
-                        if ((position + font->getHeight( ) * scale * scaleY_ > currentPosition_) &&
+                        if ((position + font->getHeight() * scale * scaleY_ > currentPosition_) &&
                             (position < currentPosition_))
                         {
-                            yAdvance  -= rect.h - static_cast<int>( font->getHeight( ) * scale * scaleX_ + position - currentPosition_ );
+                            yAdvance -= rect.h - static_cast<int>(font->getHeight() * scale * scaleX_ + position - currentPosition_);
                         }
                     }
                 }
 
-                if ( position + font->getHeight( ) * scale * scaleY_ > currentPosition_ )
+                if (position + font->getHeight() * scale * scaleY_ > currentPosition_)
                 {
                     rect.y += yAdvance;
                 }
-                position += font->getHeight( ) * scale * scaleY_;
-
+                position += font->getHeight() * scale * scaleY_;
             }
 
             // Reset scrolling position when we're done
-            if (currentPosition_ > text.size( ) * font->getHeight( ) * scale * scaleX_)
+            if (currentPosition_ > text.size() * font->getHeight() * scale * scaleX_)
             {
-                waitStartTime_   = startTime_;
-                waitEndTime_     = endTime_;
+                waitStartTime_ = startTime_;
+                waitEndTime_ = endTime_;
                 currentPosition_ = -startPosition_ * scaleY_;
             }
-
         }
     }
 }
 
-bool ReloadableScrollingText::mustRender(  )
+bool ReloadableScrollingText::mustRender()
 {
-    if ( Component::mustRender(  ) ) return true;
+    if (Component::mustRender())
+        return true;
 
-    if (!text_.empty( ) && baseViewInfo.Alpha > 0.0f && needRender_)
+    if (!text_.empty() && baseViewInfo.Alpha > 0.0f && needRender_)
     {
         needRender_ = false;
-	return true;
+        return true;
     }
 
     return false;
diff --git a/RetroFE/Source/Graphics/Component/Text.cpp b/RetroFE/Source/Graphics/Component/Text.cpp
index afb7b69..c3373b1 100755
--- a/RetroFE/Source/Graphics/Component/Text.cpp
+++ b/RetroFE/Source/Graphics/Component/Text.cpp
@@ -14,69 +14,60 @@
  * along with RetroFE.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-
 #include "Text.h"
 #include "../../Utility/Log.h"
 #include "../../SDL.h"
 #include "../Font.h"
 #include <sstream>
 
-
-Text::Text( std::string text, Page &p, Font *font, float scaleX, float scaleY )
-    : Component(p)
-    , textData_(text)
-    , fontInst_(font)
-    , scaleX_(scaleX)
-    , scaleY_(scaleY)
+Text::Text(std::string text, Page &p, Font *font, float scaleX, float scaleY)
+    : Component(p), textData_(text), fontInst_(font), scaleX_(scaleX), scaleY_(scaleY)
 {
-    allocateGraphicsMemory( );
+    allocateGraphicsMemory();
 }
 
-Text::~Text( )
+Text::~Text()
 {
-    freeGraphicsMemory( );
+    freeGraphicsMemory();
     textData_.clear();
 }
 
-void Text::freeGraphicsMemory( )
+void Text::freeGraphicsMemory()
 {
-    Component::freeGraphicsMemory( );
+    Component::freeGraphicsMemory();
     textData_.clear();
 }
 
-void Text::allocateGraphicsMemory( )
+void Text::allocateGraphicsMemory()
 {
-    Component::allocateGraphicsMemory( );
+    Component::allocateGraphicsMemory();
 }
 
-void Text::deInitializeFonts( )
+void Text::deInitializeFonts()
 {
-    fontInst_->deInitialize( );
+    fontInst_->deInitialize();
 }
 
-void Text::initializeFonts( )
+void Text::initializeFonts()
 {
-    fontInst_->initialize( );
+    fontInst_->initialize();
 }
 
-void Text::setText( std::string text, int id )
+void Text::setText(std::string text, int id)
 {
-    if ( getId( ) == id )
+    if (getId() == id)
         textData_ = text;
 }
 
-void Text::draw( )
+void Text::draw()
 {
-    Component::draw( );
+    Component::draw();
 
     Font *font;
-    if ( baseViewInfo.font ) // Use font of this specific item if available
-      font = baseViewInfo.font;
-    else                     // If not, use the general font settings
-      font = fontInst_;
-
-    //SDL_Texture *t = font->getTexture( );
-    SDL_Surface *t = font->getTexture( );
+    if (baseViewInfo.font) // Use font of this specific item if available
+        font = baseViewInfo.font;
+    else // If not, use the general font settings
+        font = fontInst_;
 
     float imageHeight = 0;
     float imageWidth = 0;
@@ -90,10 +81,10 @@ void Text::draw( )
         imageMaxWidth = baseViewInfo.MaxWidth;
     }
 
-    imageHeight = (float)font->getHeight( );
-    //float scale = (float)baseViewInfo.FontSize / (float)imageHeight;
+    imageHeight = (float)font->getHeight();
+    // float scale = (float)baseViewInfo.FontSize / (float)imageHeight;
 
-    //TODO, modify for scaling - for now, no scaling in effect
+    // TODO, modify for scaling - for now, no scaling in effect
     float scale = 1.0f;
 
     /*printf("\n");
@@ -102,79 +93,85 @@ void Text::draw( )
     unsigned int textIndexMax = 0;
 
     // determine image width
-    for ( unsigned int i = 0; i < textData_.size( ); ++i )
+    for (unsigned int i = 0; i < textData_.size();)
     {
-        Font::GlyphInfo glyph;
-        if ( font->getRect( textData_[i], glyph ) )
+        Font::GlyphInfoBuild *info;
+        unsigned int charCode;
+
+        i += font->utf8ToUcs2(&textData_[i], &charCode);
+
+        if (font->getGlyphBuild(charCode, &info))
         {
-            SDL_Rect charRect = glyph.rect;
-            //charRect.w  = static_cast<int>( glyph.advance );
-            charRect.w  = static_cast<int>( glyph.rect.w?glyph.rect.w:glyph.advance );
+            SDL_Rect charRect = info->glyph.rect;
+            // charRect.w  = static_cast<int>( glyph.advance );
+            charRect.w = static_cast<int>(info->glyph.rect.w ? info->glyph.rect.w : info->glyph.advance);
 
-            if ( glyph.minX < 0 )
+            if (info->glyph.minX < 0)
             {
-                imageWidth += glyph.minX;
+                imageWidth += info->glyph.minX;
             }
 
-            if ( (imageWidth + charRect.w)*scale > imageMaxWidth )
+            if ((imageWidth + charRect.w) * scale > imageMaxWidth)
             {
                 break;
             }
 
             textIndexMax = i;
-            imageWidth  += charRect.w;
+            imageWidth += charRect.w;
 
             /*printf("textData_[%d]=%c, glyph.advance= %f - %d\n", i, textData_[i], glyph.advance, glyph.advance);
             printf("imageWidth=%f \n", imageWidth);*/
         }
-        else{
-	    /*std::stringstream ss;
-	      ss << "Could not find Glyph info for char: " << textData_[i];
-	      Logger::write(Logger::ZONE_WARNING, "Text", ss.str());*/
+        else
+        {
+            /*std::stringstream ss;
+              ss << "Could not find Glyph info for char: " << textData_[i];
+              Logger::write(Logger::ZONE_WARNING, "Text", ss.str());*/
         }
     }
 
-    float oldWidth       = baseViewInfo.Width;
-    float oldHeight      = baseViewInfo.Height;
-    float oldImageWidth  = baseViewInfo.ImageHeight;
+    float oldWidth = baseViewInfo.Width;
+    float oldHeight = baseViewInfo.Height;
+    float oldImageWidth = baseViewInfo.ImageHeight;
     float oldImageHeight = baseViewInfo.ImageWidth;
 
-    baseViewInfo.Width       = imageWidth*scale;
-    baseViewInfo.Height      = baseViewInfo.FontSize;
-    baseViewInfo.ImageWidth  = imageWidth;
+    baseViewInfo.Width = imageWidth * scale;
+    baseViewInfo.Height = baseViewInfo.FontSize;
+    baseViewInfo.ImageWidth = imageWidth;
     baseViewInfo.ImageHeight = imageHeight;
 
-    float xOrigin = baseViewInfo.XRelativeToOrigin( );
-    float yOrigin = baseViewInfo.YRelativeToOrigin( );
+    float xOrigin = baseViewInfo.XRelativeToOrigin();
+    float yOrigin = baseViewInfo.YRelativeToOrigin();
 
-    //printf("IN TEXT %s - xOrigin=%f, yOrigin=%f\n",textData_.c_str(), xOrigin, yOrigin);
+    // printf("IN TEXT %s - xOrigin=%f, yOrigin=%f\n",textData_.c_str(), xOrigin, yOrigin);
 
-    baseViewInfo.Width       = oldWidth;
-    baseViewInfo.Height      = oldHeight;
-    baseViewInfo.ImageWidth  = oldImageWidth;
+    baseViewInfo.Width = oldWidth;
+    baseViewInfo.Height = oldHeight;
+    baseViewInfo.ImageWidth = oldImageWidth;
     baseViewInfo.ImageHeight = oldImageHeight;
 
-
     SDL_Rect rect;
-    rect.x = static_cast<int>( xOrigin );
+    rect.x = static_cast<int>(xOrigin);
 
-    for ( unsigned int i = 0; i <= textIndexMax; ++i )
+    for (unsigned int i = 0; i <= textIndexMax;)
     {
-        Font::GlyphInfo glyph;
+        Font::GlyphInfoBuild *info;
+        unsigned int charCode;
+
+        i += font->utf8ToUcs2(&textData_[i], &charCode);
 
-        //if ( font->getRect(textData_[i], glyph) && glyph.rect.h > 0 ) 	// Not working in SDL1.2 because glyph.rect.h = 0 for spaces
-        if ( font->getRect(textData_[i], glyph))
+        if (font->getGlyphBuild(charCode, &info))
         {
-            SDL_Rect charRect = glyph.rect;
-            float h = static_cast<float>( charRect.h * scale );
-            float w = static_cast<float>( (charRect.w?charRect.w:glyph.advance) * scale );
-            rect.h = static_cast<int>( h );
-            rect.w = static_cast<int>( w );
-            rect.y = static_cast<int>( yOrigin );
-
-            if(glyph.minX < 0)
+            SDL_Rect charRect = info->glyph.rect;
+            float h = static_cast<float>(charRect.h * scale);
+            float w = static_cast<float>((charRect.w ? charRect.w : info->glyph.advance) * scale);
+            rect.h = static_cast<int>(h);
+            rect.w = static_cast<int>(w);
+            rect.y = static_cast<int>(yOrigin);
+
+            if (info->glyph.minX < 0)
             {
-                rect.x += static_cast<int>( (float)(glyph.minX) * scale );
+                rect.x += static_cast<int>((float)(info->glyph.minX) * scale);
             }
             /*if ( font->getAscent( ) < glyph.maxY )
             {
@@ -182,9 +179,9 @@ void Text::draw( )
             }*/
 
             /*printf("font->getAscent( ) = %d, glyph.maxY : %d\n", font->getAscent( ), glyph.maxY );*/
-            rect.y += static_cast<int>( (font->getAscent( ) - glyph.maxY)*scale );
+            rect.y += static_cast<int>((font->getAscent() - info->glyph.maxY) * scale);
 
-            SDL::renderCopy( t, baseViewInfo.Alpha, &charRect, &rect, baseViewInfo );
+            SDL::renderCopy(info->surface, baseViewInfo.Alpha, &charRect, &rect, baseViewInfo);
 
             rect.x += rect.w;
         }
diff --git a/RetroFE/Source/Graphics/Font.cpp b/RetroFE/Source/Graphics/Font.cpp
index 2e078e8..61d87d5 100755
--- a/RetroFE/Source/Graphics/Font.cpp
+++ b/RetroFE/Source/Graphics/Font.cpp
@@ -18,15 +18,15 @@
 #include "../Utility/Log.h"
 #include <SDL/SDL.h>
 #include <SDL/SDL_ttf.h>
-//#include <SDL/SDL_gfxBlitFunc.h>
+// #include <SDL/SDL_gfxBlitFunc.h>
 #include <cstdio>
 #include <cstring>
 
+#define DEFAULT_ATLAS_WIDTH 512
+#define DEFAULT_ATLAS_HEIGHT 512
+
 Font::Font(std::string fontPath, int fontSize, SDL_Color color)
-    : texture(NULL)
-    , fontPath_(fontPath)
-    , fontSize_(fontSize)
-    , color_(color)
+    : fontPath_(fontPath), fontSize_(fontSize), color_(color)
 {
 }
 
@@ -35,11 +35,6 @@ Font::~Font()
     deInitialize();
 }
 
-SDL_Surface *Font::getTexture()
-{
-    return texture;
-}
-
 int Font::getHeight()
 {
     return height;
@@ -48,79 +43,28 @@ int Font::getAscent()
 {
     return ascent;
 }
-bool Font::getRect(unsigned int charCode, GlyphInfo &glyph)
-{
-    std::map<unsigned int, GlyphInfoBuild *>::iterator it = atlas.find(charCode);
 
-    if(it != atlas.end())
+int Font::utf8ToUcs2(const char *utf8, unsigned int *charCode)
+{
+    if (((utf8[0] & 0xF0) == 0xE0) && ((utf8[1] & 0xC0) == 0x80) && ((utf8[2] & 0xC0) == 0x80))
     {
-        GlyphInfoBuild *info = it->second;
-
-        glyph = info->glyph;
-
-        return true;
+        *charCode = ((utf8[0] & 0x0F) << 12) | ((utf8[1] & 0x3F) << 6) | (utf8[2] & 0x3F);
+        return 3;
     }
-
-    return false;
-}
-
-bool Font::initialize()
-{
-    TTF_Font *font = TTF_OpenFont(fontPath_.c_str(), fontSize_);
-
-    if (!font)
+    else if (((utf8[0] & 0xE0) == 0xC0) && ((utf8[1] & 0xC0) == 0x80))
     {
-        std::stringstream ss;
-        ss << "Could not open font: " << TTF_GetError();
-        Logger::write(Logger::ZONE_ERROR, "FontCache", ss.str());
-        return false;
+        *charCode = ((utf8[0] & 0x1F) << 6) | (utf8[1] & 0x3F);
+        return 2;
     }
-
-    int x = 0;
-    int y = 0;
-    int atlasHeight = 0;
-    int atlasWidth = 0;
-    height = TTF_FontHeight(font);
-    ascent = TTF_FontAscent(font);
-
-    for(unsigned short int i = 32; i < 128; ++i)
+    else
     {
-        GlyphInfoBuild *info = new GlyphInfoBuild;
-        memset(info, 0, sizeof(GlyphInfoBuild));
-
-        //color_.a = 255;
-        info->surface = TTF_RenderGlyph_Blended(font, i, color_);
-        TTF_GlyphMetrics(font, i,
-        		&info->glyph.minX, &info->glyph.maxX,
-        		&info->glyph.minY, &info->glyph.maxY,
-        		&info->glyph.advance);
-
-        if(x + info->surface->w >= 1024)
-        {
-            atlasHeight += y;
-            atlasWidth = (atlasWidth >= x) ? atlasWidth : x;
-            x = 0;
-            y = 0;
-        }
-
-        info->glyph.rect.w = info->surface->w;
-        info->glyph.rect.h = info->surface->h;
-        info->glyph.rect.x = x;
-        info->glyph.rect.y = atlasHeight;
-        atlas[i] = info;
-
-        x += info->glyph.rect.w;
-        y = (y > info->glyph.rect.h) ? y : info->glyph.rect.h;
-
-        /*std::stringstream ss;
-        ss << " tw:" << atlasWidth << " th:" << atlasHeight << " x:" << x << " y:" << y << " w:" << info->glyph.rect.w << " h:" << info->glyph.rect.h;
-        Logger::write(Logger::ZONE_INFO, "FontCache", ss.str());*/
-
+        *charCode = utf8[0];
+        return 1;
     }
+}
 
-    atlasWidth = (atlasWidth >= x) ? atlasWidth : x;
-    atlasHeight += y;
-
+SDL_Surface *Font::creatAtlasSurface()
+{
     unsigned int rmask;
     unsigned int gmask;
     unsigned int bmask;
@@ -137,59 +81,129 @@ bool Font::initialize()
     amask = 0xff000000;
 #endif
 
-    //SDL_Surface *atlasSurface = SDL_CreateRGBSurface(0, atlasWidth, atlasHeight, 32, rmask, gmask, bmask, amask);
-    texture = SDL_CreateRGBSurface(0, atlasWidth, atlasHeight, 32, rmask, gmask, bmask, amask);
-    SDL_FillRect(texture, NULL, SDL_MapRGBA(texture->format, 0, 0, 0, 0));
+    SDL_Surface *surface = SDL_CreateRGBSurface(0, DEFAULT_ATLAS_WIDTH, DEFAULT_ATLAS_HEIGHT, 32, rmask, gmask, bmask, amask);
+    if (!surface)
+        return NULL;
 
-    /*texture = SDL_CreateRGBSurface(0, atlasWidth, atlasHeight, 32, 0, 0, 0, 0);
-    int transparentColorKey = SDL_MapRGB(texture->format, color_.r-1, color_.g-1, color_.b-1);
-    SDL_FillRect(texture, NULL, transparentColorKey);
-    SDL_SetColorKey(texture, SDL_SRCCOLORKEY, transparentColorKey);*/
+    SDL_FillRect(surface, NULL, SDL_MapRGBA(surface->format, 0, 0, 0, 0));
+    return surface;
+}
 
-    std::map<unsigned int, GlyphInfoBuild *>::iterator it;
-    for(it = atlas.begin(); it != atlas.end(); it++)
+bool Font::addGlyphBuild(unsigned int charCode, GlyphInfoBuild **build)
+{
+    if (!font || !charCode)
+        return false;
+
+    SDL_Surface *surface = TTF_RenderGlyph_Blended(font, charCode, color_);
+    if (!surface)
+        return false;
+
+    GlyphInfoBuild *info = new GlyphInfoBuild;
+    memset(info, 0, sizeof(GlyphInfoBuild));
+
+    TTF_GlyphMetrics(font, charCode,
+                     &info->glyph.minX, &info->glyph.maxX,
+                     &info->glyph.minY, &info->glyph.maxY,
+                     &info->glyph.advance);
+
+    // 超过地图宽度,换行
+    if (atlasX + surface->w >= DEFAULT_ATLAS_WIDTH)
+    {
+        atlasX = 0;
+        atlasY += atlasYSpace;
+        atlasYSpace = 0;
+    }
+
+    atlasYSpace = (atlasYSpace > surface->h) ? atlasYSpace : surface->h;
+
+    // 超过地图高度,创建新地图
+    if (surfaces.size() == 0 || atlasY + atlasYSpace >= DEFAULT_ATLAS_HEIGHT)
     {
-        GlyphInfoBuild *info = it->second;
-        //SDL_BlitSurface(info->surface, NULL, atlasSurface, &info->glyph.rect);
-        SDL_SetAlpha( info->surface, 0, SDL_ALPHA_OPAQUE );
-        SDL_BlitSurface(info->surface, NULL, texture, &info->glyph.rect);
-        //SDL_gfxBlitRGBA (info->surface, NULL, texture, &info->glyph.rect);
-        SDL_FreeSurface(info->surface);
-        info->surface = NULL;
+        atlasX = 0;
+        atlasY = 0;
+        SDL_Surface *atlasSurface = creatAtlasSurface();
+        if (!atlasSurface)
+        {
+            SDL_FreeSurface(surface);
+            return false;
+        }
+        surfaces.push_back(atlasSurface);
     }
 
-    /*SDL_LockMutex(SDL::getMutex());
-    //texture = SDL_CreateTextureFromSurface(SDL::getRenderer(), atlasSurface);
-    //SDL_SetTextureBlendMode(texture, SDL_BLENDMODE_BLEND);
-    SDL_FreeSurface(atlasSurface);
-    SDL_UnlockMutex(SDL::getMutex());*/
+    info->surface = surfaces.back();
+    info->glyph.rect.w = surface->w;
+    info->glyph.rect.h = surface->h;
+    info->glyph.rect.x = atlasX;
+    info->glyph.rect.y = atlasY;
+    atlas[charCode] = info;
+
+    SDL_LockMutex(SDL::getMutex());
+    SDL_SetAlpha(surface, 0, SDL_ALPHA_OPAQUE);
+    SDL_BlitSurface(surface, NULL, info->surface, &info->glyph.rect);
+    SDL_UnlockMutex(SDL::getMutex());
+    SDL_FreeSurface(surface);
 
-    TTF_CloseFont(font);
+    atlasX += info->glyph.rect.w;
 
+    *build = info;
     return true;
 }
 
+bool Font::getGlyphBuild(unsigned int charCode, GlyphInfoBuild **build)
+{
+    std::map<unsigned int, GlyphInfoBuild *>::iterator it = atlas.find(charCode);
+
+    if (it != atlas.end())
+    {
+        *build = it->second;
+        return true;
+    }
+
+    return addGlyphBuild(charCode, build);
+}
+
+bool Font::initialize()
+{
+    font = TTF_OpenFont(fontPath_.c_str(), fontSize_);
+
+    if (!font)
+    {
+        std::stringstream ss;
+        ss << "Could not open font: " << TTF_GetError();
+        Logger::write(Logger::ZONE_ERROR, "FontCache", ss.str());
+        return false;
+    }
+
+    atlasX = 0;
+    atlasY = 0;
+    atlasYSpace = 0;
+    height = TTF_FontHeight(font);
+    ascent = TTF_FontAscent(font);
 
+    return true;
+}
 
 void Font::deInitialize()
 {
-    if(texture)
+    if (font)
+    {
+        TTF_CloseFont(font);
+        font = NULL;
+    }
+
+    while (surfaces.size() > 0)
     {
         SDL_LockMutex(SDL::getMutex());
-        //SDL_DestroyTexture(texture);
-        SDL_FreeSurface(texture);
-        texture = NULL;
+        SDL_FreeSurface(surfaces.back());
         SDL_UnlockMutex(SDL::getMutex());
+        surfaces.pop_back();
     }
 
     std::map<unsigned int, GlyphInfoBuild *>::iterator atlasIt = atlas.begin();
-    while(atlasIt != atlas.end())
+    while (atlasIt != atlas.end())
     {
         delete atlasIt->second;
         atlas.erase(atlasIt);
         atlasIt = atlas.begin();
     }
-
 }
-
-
diff --git a/RetroFE/Source/Graphics/Font.h b/RetroFE/Source/Graphics/Font.h
index cb4951f..8b64283 100755
--- a/RetroFE/Source/Graphics/Font.h
+++ b/RetroFE/Source/Graphics/Font.h
@@ -16,8 +16,10 @@
 #pragma once
 
 #include <SDL/SDL.h>
+#include <SDL/SDL_ttf.h>
 #include <map>
 #include <string>
+#include <vector>
 
 class Font
 {
@@ -31,30 +33,35 @@ public:
         int advance;
         SDL_Rect rect;
     };
+    
+    struct GlyphInfoBuild
+    {
+        Font::GlyphInfo glyph;
+        SDL_Surface *surface;
+    };
 
     Font(std::string fontPath, int fontSize, SDL_Color color);
     virtual ~Font();
     bool initialize();
     void deInitialize();
-    //SDL_Texture *getTexture();
-    SDL_Surface *getTexture();
-    bool getRect(unsigned int charCode, GlyphInfo &glyph);
+    bool getGlyphBuild(unsigned int charCode, GlyphInfoBuild **build);
     int getHeight();
     int getAscent();
+    int utf8ToUcs2(const char *utf8, unsigned int *charCode);
 
 private:
-    struct GlyphInfoBuild
-    {
-        Font::GlyphInfo glyph;
-        SDL_Surface *surface;
-    };
-
-    //SDL_Texture *texture;
-    SDL_Surface *texture;
+    TTF_Font *font;
+    std::vector<SDL_Surface *> surfaces;
     int height;
     int ascent;
+    int atlasX;
+    int atlasY;
+    int atlasYSpace;
     std::map<unsigned int, GlyphInfoBuild *> atlas;
     std::string fontPath_;
     int fontSize_;
     SDL_Color color_;
+
+    SDL_Surface *creatAtlasSurface();
+    bool addGlyphBuild(unsigned int charCode, GlyphInfoBuild **build);
 };
diff --git a/RetroFE/Source/Menu/MenuMode.cpp b/RetroFE/Source/Menu/MenuMode.cpp
index 8cce5c7..a7191ef 100755
--- a/RetroFE/Source/Menu/MenuMode.cpp
+++ b/RetroFE/Source/Menu/MenuMode.cpp
@@ -23,10 +23,10 @@
 #define MENU_ERROR_PRINTF(...)
 #endif //MENU_ERROR
 
-#define SCREEN_HORIZONTAL_SIZE      240 //RES_HW_SCREEN_HORIZONTAL
-#define SCREEN_VERTICAL_SIZE        240 //RES_HW_SCREEN_VERTICAL
+#define SCREEN_HORIZONTAL_SIZE      640 //RES_HW_SCREEN_HORIZONTAL
+#define SCREEN_VERTICAL_SIZE        480 //RES_HW_SCREEN_VERTICAL
 
-#define SCROLL_SPEED_PX             30
+#define SCROLL_SPEED_PX             100
 #define FPS_MENU                    60
 #define ARROWS_PADDING              8
 
@@ -35,12 +35,18 @@
 #define MENU_BG_SQURE_WIDTH         180
 #define MENU_BG_SQUREE_HEIGHT       140
 
-#define MENU_FONT_NAME_TITLE        "/usr/games/menu_resources/OpenSans-Bold.ttf"
-#define MENU_FONT_SIZE_TITLE        22
-#define MENU_FONT_NAME_INFO         "/usr/games/menu_resources/OpenSans-Bold.ttf"
-#define MENU_FONT_SIZE_INFO         16
-#define MENU_FONT_NAME_SMALL_INFO   "/usr/games/menu_resources/OpenSans-Regular.ttf"
-#define MENU_FONT_SIZE_SMALL_INFO   13
+//#define MENU_FONT_NAME_TITLE        "/usr/games/menu_resources/OpenSans-Bold.ttf"
+#define MENU_FONT_NAME_TITLE        "/usr/games/menu_resources/FZZhunYuan-M02S.ttf"
+#define MENU_FONT_SIZE_TITLE        28
+
+//#define MENU_FONT_NAME_INFO         "/usr/games/menu_resources/OpenSans-Bold.ttf"
+#define MENU_FONT_NAME_INFO         "/usr/games/menu_resources/FZZhunYuan-M02S.ttf"
+#define MENU_FONT_SIZE_INFO         22
+
+//#define MENU_FONT_NAME_SMALL_INFO   "/usr/games/menu_resources/OpenSans-Regular.ttf"
+#define MENU_FONT_NAME_SMALL_INFO    "/usr/games/menu_resources/simhei.ttf"
+#define MENU_FONT_SIZE_SMALL_INFO   18
+
 #define MENU_PNG_BG_PATH            "/usr/games/menu_resources/zone_bg.png"
 #define MENU_PNG_ARROW_TOP_PATH     "/usr/games/menu_resources/arrow_top.png"
 #define MENU_PNG_ARROW_BOTTOM_PATH  "/usr/games/menu_resources/arrow_bottom.png"
@@ -263,7 +269,7 @@ void MenuMode::add_menu_zone(ENUM_MENU_TYPE menu_type){
 	case MENU_TYPE_VOLUME:
 		MENU_DEBUG_PRINTF("Init MENU_TYPE_VOLUME\n");
 		/// ------ Text ------
-		text_surface = TTF_RenderText_Blended(menu_title_font, "VOLUME", text_color);
+		text_surface = TTF_RenderUTF8_Blended(menu_title_font, "音量", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 - padding_y_from_center_menu_zone;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);
@@ -276,7 +282,7 @@ void MenuMode::add_menu_zone(ENUM_MENU_TYPE menu_type){
 	case MENU_TYPE_BRIGHTNESS:
 		MENU_DEBUG_PRINTF("Init MENU_TYPE_BRIGHTNESS\n");
 		/// ------ Text ------
-		text_surface = TTF_RenderText_Blended(menu_title_font, "BRIGHTNESS", text_color);
+		text_surface = TTF_RenderUTF8_Blended(menu_title_font, "亮度", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 - padding_y_from_center_menu_zone;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);
@@ -289,7 +295,7 @@ void MenuMode::add_menu_zone(ENUM_MENU_TYPE menu_type){
 	case MENU_TYPE_SAVE:
 		MENU_DEBUG_PRINTF("Init MENU_TYPE_SAVE\n");
 		/// ------ Text ------
-		text_surface = TTF_RenderText_Blended(menu_title_font, "SAVE", text_color);
+		text_surface = TTF_RenderUTF8_Blended(menu_title_font, "保存", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 - padding_y_from_center_menu_zone*2;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);
@@ -297,7 +303,7 @@ void MenuMode::add_menu_zone(ENUM_MENU_TYPE menu_type){
 	case MENU_TYPE_LOAD:
 		MENU_DEBUG_PRINTF("Init MENU_TYPE_LOAD\n");
 		/// ------ Text ------
-		text_surface = TTF_RenderText_Blended(menu_title_font, "LOAD", text_color);
+		text_surface = TTF_RenderUTF8_Blended(menu_title_font, "加载", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 - padding_y_from_center_menu_zone*2;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);
@@ -305,7 +311,7 @@ void MenuMode::add_menu_zone(ENUM_MENU_TYPE menu_type){
 	case MENU_TYPE_ASPECT_RATIO:
 		MENU_DEBUG_PRINTF("Init MENU_TYPE_ASPECT_RATIO\n");
 		/// ------ Text ------
-		text_surface = TTF_RenderText_Blended(menu_title_font, "ASPECT RATIO", text_color);
+		text_surface = TTF_RenderUTF8_Blended(menu_title_font, "纵横比", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 - padding_y_from_center_menu_zone;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);
@@ -313,7 +319,7 @@ void MenuMode::add_menu_zone(ENUM_MENU_TYPE menu_type){
 	case MENU_TYPE_EXIT:
 		MENU_DEBUG_PRINTF("Init MENU_TYPE_EXIT\n");
 		/// ------ Text ------
-		text_surface = TTF_RenderText_Blended(menu_title_font, "EXIT GAME", text_color);
+		text_surface = TTF_RenderUTF8_Blended(menu_title_font, "退出游戏", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);
@@ -321,7 +327,7 @@ void MenuMode::add_menu_zone(ENUM_MENU_TYPE menu_type){
 	case MENU_TYPE_USB:
 		MENU_DEBUG_PRINTF("Init MENU_TYPE_USB\n");
 		/// ------ Text ------
-		/*text_surface = TTF_RenderText_Blended(menu_title_font, "USB", text_color);
+		/*text_surface = TTF_RenderUTF8_Blended(menu_title_font, "USB", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);*/
@@ -329,7 +335,7 @@ void MenuMode::add_menu_zone(ENUM_MENU_TYPE menu_type){
 	case MENU_TYPE_THEME:
 		MENU_DEBUG_PRINTF("Init MENU_TYPE_THEME\n");
 		/// ------ Text ------
-		text_surface = TTF_RenderText_Blended(menu_title_font, "SET THEME", text_color);
+		text_surface = TTF_RenderUTF8_Blended(menu_title_font, "主题设置", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 - padding_y_from_center_menu_zone*2;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);
@@ -337,12 +343,12 @@ void MenuMode::add_menu_zone(ENUM_MENU_TYPE menu_type){
 	case MENU_TYPE_LAUNCHER:
 		MENU_DEBUG_PRINTF("Init MENU_TYPE_LAUNCHER\n");
 		/// ------ Text ------
-		text_surface = TTF_RenderText_Blended(menu_title_font, "SET LAUNCHER", text_color);
+		text_surface = TTF_RenderUTF8_Blended(menu_title_font, "启动器设置", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 - padding_y_from_center_menu_zone*2;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);
 		/// ------ Text ------
-		text_surface = TTF_RenderText_Blended(menu_title_font, "GMENU2X", text_color);
+		text_surface = TTF_RenderUTF8_Blended(menu_title_font, "GMENU2X", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);
@@ -350,7 +356,7 @@ void MenuMode::add_menu_zone(ENUM_MENU_TYPE menu_type){
 	case MENU_TYPE_POWERDOWN:
 		MENU_DEBUG_PRINTF("Init MENU_TYPE_POWERDOWN\n");
 		/// ------ Text ------
-		text_surface = TTF_RenderText_Blended(menu_title_font, "POWERDOWN", text_color);
+		text_surface = TTF_RenderUTF8_Blended(menu_title_font, "关机", text_color);
 		text_pos.x = (surface->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 		text_pos.y = surface->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2;
 		SDL_BlitSurface(text_surface, NULL, surface, &text_pos);
@@ -522,20 +528,20 @@ void MenuMode::menu_screen_refresh(int menuItem, int prevItem, int scroll, uint8
 
 		case MENU_TYPE_SAVE:
 			/// ---- Write slot -----
-			sprintf(text_tmp, "IN SLOT   < %d >", savestate_slot+1);
-			text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+			sprintf(text_tmp, "从插槽 < %d >", savestate_slot+1);
+			text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 			text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 			text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2;
 			SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
 
 			if(menu_action){
-				sprintf(text_tmp, "Saving...");
-				text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+				sprintf(text_tmp, "保存中...");
+				text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 			}
 			else{
 				if(menu_confirmation){
-					sprintf(text_tmp, "Are you sure ?");
-					text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+					sprintf(text_tmp, "你确定吗?");
+					text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 				}
 				else{
 					/// ---- Write current Save state ----
@@ -548,20 +554,20 @@ void MenuMode::menu_screen_refresh(int menuItem, int prevItem, int scroll, uint8
 
 		case MENU_TYPE_LOAD:
 			/// ---- Write slot -----
-			sprintf(text_tmp, "FROM SLOT   < %d >", savestate_slot+1);
-			text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+			sprintf(text_tmp, "从插槽 < %d >", savestate_slot+1);
+			text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 			text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 			text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2;
 			SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
 
 			if(menu_action){
-				sprintf(text_tmp, "Loading...");
-				text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+				sprintf(text_tmp, "加载中...");
+				text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 			}
 			else{
 				if(menu_confirmation){
-					sprintf(text_tmp, "Are you sure ?");
-					text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+					sprintf(text_tmp, "你确定吗?");
+					text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 				}
 				else{
 					/// ---- Write current Load state ----
@@ -574,7 +580,7 @@ void MenuMode::menu_screen_refresh(int menuItem, int prevItem, int scroll, uint8
 
 		case MENU_TYPE_ASPECT_RATIO:
 			sprintf(text_tmp, "<   %s   >", aspect_ratio_name[aspect_ratio]);
-			text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+			text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 			text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 			text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 + padding_y_from_center_menu_zone;
 			SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
@@ -582,22 +588,22 @@ void MenuMode::menu_screen_refresh(int menuItem, int prevItem, int scroll, uint8
 
 		case MENU_TYPE_USB:
 			/// ---- Write slot -----
-			sprintf(text_tmp, "%s USB", usb_sharing?"EJECT":"MOUNT");
-			text_surface = TTF_RenderText_Blended(menu_title_font, text_tmp, text_color);
+			sprintf(text_tmp, "%s USB", usb_sharing?"弹出":"挂载");
+			text_surface = TTF_RenderUTF8_Blended(menu_title_font, text_tmp, text_color);
 			text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 			text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2;
 			SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
 
 			if(menu_action){
-				sprintf(text_tmp, "in progress ...");
-				text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+				sprintf(text_tmp, "执行中...");
+				text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 				text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 				text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 + 2*padding_y_from_center_menu_zone;
 				SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
 			}
 			else if(menu_confirmation){
-				sprintf(text_tmp, "Are you sure ?");
-				text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+				sprintf(text_tmp, "你确定吗?");
+				text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 				text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 				text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 + 2*padding_y_from_center_menu_zone;
 				SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
@@ -618,21 +624,21 @@ void MenuMode::menu_screen_refresh(int menuItem, int prevItem, int scroll, uint8
 			}
 			sprintf(text_tmp, "< %s%s >", curLayoutName, dots?"...":"" );
 
-			text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+			text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 			text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 			text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2;
 			SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
 
 			if(menu_action){
-				sprintf(text_tmp, "In progress...");
-				text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+				sprintf(text_tmp, "执行中...");
+				text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 				text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 				text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 + 2*padding_y_from_center_menu_zone;
 				SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
 			}
 			else if(menu_confirmation){
-				sprintf(text_tmp, "Are you sure ?");
-				text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+				sprintf(text_tmp, "你确定吗?");
+				text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 				text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 				text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 + 2*padding_y_from_center_menu_zone;
 				SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
@@ -641,15 +647,15 @@ void MenuMode::menu_screen_refresh(int menuItem, int prevItem, int scroll, uint8
 
 		case MENU_TYPE_LAUNCHER:
 			if(menu_action){
-				sprintf(text_tmp, "In progress...");
-				text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+				sprintf(text_tmp, "执行中...");
+				text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 				text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 				text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 + 2*padding_y_from_center_menu_zone;
 				SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
 			}
 			else if(menu_confirmation){
-				sprintf(text_tmp, "Are you sure ?");
-				text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+				sprintf(text_tmp, "你确定吗?");
+				text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 				text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 				text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 + 2*padding_y_from_center_menu_zone;
 				SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
@@ -659,16 +665,16 @@ void MenuMode::menu_screen_refresh(int menuItem, int prevItem, int scroll, uint8
 		case MENU_TYPE_EXIT:
 		case MENU_TYPE_POWERDOWN:
 			if(menu_action){
-				sprintf(text_tmp, "Shutting down...");
-				text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+				sprintf(text_tmp, "关机中...");
+				text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 				text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 				text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 + 2*padding_y_from_center_menu_zone;
 				SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
 			}
 			else{
 				if(menu_confirmation){
-					sprintf(text_tmp, "Are you sure ?");
-					text_surface = TTF_RenderText_Blended(menu_info_font, text_tmp, text_color);
+					sprintf(text_tmp, "你确定吗?");
+					text_surface = TTF_RenderUTF8_Blended(menu_info_font, text_tmp, text_color);
 					text_pos.x = (virtual_hw_screen->w - MENU_ZONE_WIDTH)/2 + (MENU_ZONE_WIDTH - text_surface->w)/2;
 					text_pos.y = virtual_hw_screen->h - MENU_ZONE_HEIGHT/2 - text_surface->h/2 + 2*padding_y_from_center_menu_zone;
 					SDL_BlitSurface(text_surface, NULL, virtual_hw_screen, &text_pos);
diff --git a/RetroFE/Source/SDL.cpp b/RetroFE/Source/SDL.cpp
index 29febe9..43ec289 100755
--- a/RetroFE/Source/SDL.cpp
+++ b/RetroFE/Source/SDL.cpp
@@ -164,7 +164,7 @@ bool SDL::initialize( Configuration &config )
 
         Logger::write( Logger::ZONE_INFO, "SDL", ss.str( ));
 
-        window_ = SDL_SetVideoMode(windowWidth_, windowHeight_, 32, windowFlags);
+        window_ = SDL_SetVideoMode(windowWidth_, windowHeight_, 16, windowFlags);
         if ( window_ == NULL )
         {
             std::string error = SDL_GetError( );
@@ -187,7 +187,7 @@ bool SDL::initialize( Configuration &config )
         bmask = 0x00ff0000;
         amask = 0xff000000;
 #endif*/
-        window_virtual_ = SDL_CreateRGBSurface(0, windowWidth_, windowHeight_, 32, 0,0,0,0);
+        window_virtual_ = SDL_CreateRGBSurface(0, windowWidth_, windowHeight_, 16, 0,0,0,0);
         //window_virtual_ = SDL_CreateRGBSurface(0, windowWidth_, windowHeight_, 32, rmask, gmask, bmask, amask); // colors are reversed with this !
         if ( window_virtual_ == NULL )
         {
@@ -456,8 +456,8 @@ void SDL::ditherSurface32bppTo16Bpp(SDL_Surface * src_surface){
 // Copy virtual window to HW window and Flip display
 void SDL::renderAndFlipWindow( )
 {
-	//SDL_BlitSurface(window_virtual_, NULL, window_, NULL);
-    memcpy(window_->pixels, window_virtual_->pixels, window_->h*window_->w*sizeof(uint32_t));
+	SDL_BlitSurface(window_virtual_, NULL, window_, NULL);
+    //memcpy(window_->pixels, window_virtual_->pixels, window_->h*window_->w*sizeof(uint32_t));
 	//SDL_Rotate_270(window_virtual_, window_);
 
 	SDL_Flip(window_);
-- 
2.25.1

